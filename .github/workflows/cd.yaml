name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
    branches: [master, dev]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

# Status badge URLs:
# https://github.com/mhmd-zbib/ai-recruitment-server/actions/workflows/cd.yaml/badge.svg?branch=master
# https://github.com/mhmd-zbib/ai-recruitment-server/actions/workflows/cd.yaml/badge.svg?branch=dev

# Grant required permissions
permissions:
  contents: write    # Needed for creating releases
  packages: write    # Needed for GitHub Container Registry (ghcr.io)

concurrency:
  group: ${{ github.workflow }}-${{ github.event.workflow_run.conclusion || github.event.inputs.environment }}
  cancel-in-progress: false

env:
  DOCKER_IMAGE: hiresync
  DOCKER_REGISTRY: docker.io
  DOCKER_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  # Environment variables
  SPRING_PROFILES_ACTIVE: prod
  DEBUG_MODE: false
  SPRINGDOC_ENABLED: false
  SWAGGER_UI_ENABLED: false
  # Database configuration
  POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}
  POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
  POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
  POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      version: ${{ steps.set-version.outputs.version }}
      branch: ${{ steps.set-version.outputs.branch }}
      image_tag: ${{ steps.set-version.outputs.image_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}

      - name: Set environment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event.workflow_run.head_branch || github.ref_name }}" == "master" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Set version and tags
        id: set-version
        run: |
          BRANCH="${{ github.event.workflow_run.head_branch || github.ref_name }}"
          VERSION="$(git describe --tags --abbrev=0 2>/dev/null || echo 'v0.1.0')-$(git rev-parse --short HEAD)"
          IMAGE_TAG="${BRANCH}-$(git rev-parse --short HEAD)"

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

          echo "Using version: $VERSION"
          echo "Branch: $BRANCH"
          echo "Image tag: $IMAGE_TAG"
          echo "Environment: ${{ steps.set-env.outputs.environment }}"

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven
        run: mvn -B package -DskipTests

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile
          target: runtime
          push: true
          tags: |
            ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ steps.set-version.outputs.image_tag }}
            ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ steps.set-version.outputs.branch }}-latest
            ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ steps.set-version.outputs.version }}
          platforms: linux/amd64
          build-args: |
            SPRING_PROFILES_ACTIVE=${{ env.SPRING_PROFILES_ACTIVE }}
            DEBUG_MODE=${{ env.DEBUG_MODE }}
            SPRINGDOC_ENABLED=${{ env.SPRINGDOC_ENABLED }}
            SWAGGER_UI_ENABLED=${{ env.SWAGGER_UI_ENABLED }}

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: needs.build-and-push.outputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.hiresync.example.com
    steps:
      - name: Deploy to Staging
        run: |
          echo "Deploying version ${{ needs.build-and-push.outputs.version }} to staging environment"
          echo "Using image: ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ needs.build-and-push.outputs.branch }}-latest"

          # Here you would add your actual deployment steps
          # For example, using SSH to connect to your staging server and update the containers
          # or using a deployment tool like Ansible, Terraform, or a cloud provider's CLI

          echo "✅ Deployment to staging completed successfully"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    if: needs.build-and-push.outputs.environment == 'production'
    environment:
      name: production
      url: https://hiresync.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Deploy to Production
        run: |
          echo "Deploying version ${{ needs.build-and-push.outputs.version }} to production environment"
          echo "Using image: ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ needs.build-and-push.outputs.branch }}-latest"

          # Here you would add your actual deployment steps
          # For example, using SSH to connect to your production server and update the containers
          # or using a deployment tool like Ansible, Terraform, or a cloud provider's CLI

          echo "✅ Deployment to production completed successfully"

      - name: Create Release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.build-and-push.outputs.version }}
          name: Release ${{ needs.build-and-push.outputs.version }}
          body: |
            Release ${{ needs.build-and-push.outputs.version }}
            Deployed on $(date)

            This release has been built and published to Docker Hub.
            Deployment is handled automatically.
          draft: false
          token: ${{ secrets.GITHUB_TOKEN }}

  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging, deploy-production]
    if: always()
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [[ "${{ needs.build-and-push.result }}" == "success" &&
                ("${{ needs.deploy-staging.result }}" == "success" || "${{ needs.deploy-staging.result }}" == "skipped") &&
                ("${{ needs.deploy-production.result }}" == "success" || "${{ needs.deploy-production.result }}" == "skipped") ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi

      - name: Send success notification
        if: steps.status.outputs.status == 'success'
        run: |
          echo "✅ Deployment to ${{ needs.build-and-push.outputs.environment }} completed successfully"
          echo "Version: ${{ needs.build-and-push.outputs.version }}"
          echo "Branch: ${{ needs.build-and-push.outputs.branch }}"
          echo "Image: ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:${{ needs.build-and-push.outputs.image_tag }}"
          # Here you would add your actual notification steps
          # For example, sending a message to Slack, Teams, or an email

      - name: Send failure notification
        if: steps.status.outputs.status == 'failure'
        run: |
          echo "❌ Deployment to ${{ needs.build-and-push.outputs.environment }} failed"
          echo "Version: ${{ needs.build-and-push.outputs.version }}"
          echo "Branch: ${{ needs.build-and-push.outputs.branch }}"
          # Here you would add your actual notification steps
          # For example, sending a message to Slack, Teams, or an email
