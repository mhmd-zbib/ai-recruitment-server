#!/bin/bash
# HireSync Main Command Runner
# This script provides unified interface for all HireSync operations

set -e

# Detect script directory and project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
export PROJECT_ROOT="${SCRIPT_DIR}"

# Import core utilities
source "${PROJECT_ROOT}/scripts/core/colors.sh"
source "${PROJECT_ROOT}/scripts/core/logging.sh"
source "${PROJECT_ROOT}/scripts/core/env.sh"

# Import utility scripts
source "${PROJECT_ROOT}/scripts/db/db.sh"
source "${PROJECT_ROOT}/scripts/utils/docker.sh"

# Global Variables
COMMAND=""
SUB_COMMAND=""
ARGS=()

# Function to display usage and help information
show_help() {
  echo -e "${BOLD}HireSync Command Runner${NC}"
  echo -e "Unified interface for all HireSync operations\n"
  echo -e "${BOLD}Usage:${NC}"
  echo -e "  ./run <command> [subcommand] [options]\n"
  echo -e "${BOLD}Available Commands:${NC}"
  echo -e "  ${CYAN}help${NC}              Display this help message"
  echo -e "  ${CYAN}setup${NC}             Setup the development environment"
  echo -e "  ${CYAN}db${NC}                Database operations"
  echo -e "    ${GRAY}start${NC}           Start the database container"
  echo -e "    ${GRAY}stop${NC}            Stop the database container"
  echo -e "    ${GRAY}status${NC}          Check database status"
  echo -e "    ${GRAY}init${NC}            Initialize the database with schema"
  echo -e "    ${GRAY}backup [dir]${NC}    Create database backup"
  echo -e "    ${GRAY}restore <file>${NC}  Restore database from backup"
  echo -e "    ${GRAY}shell${NC}           Open database shell"
  echo -e "  ${CYAN}dev${NC}               Development operations"
  echo -e "    ${GRAY}run${NC}             Run the application in development mode"
  echo -e "    ${GRAY}test${NC}            Run tests"
  echo -e "    ${GRAY}clean${NC}           Clean build artifacts"
  echo -e "  ${CYAN}docker${NC}            Docker operations"
  echo -e "    ${GRAY}build [tag]${NC}     Build Docker image"
  echo -e "    ${GRAY}up${NC}              Start application stack with Docker Compose"
  echo -e "    ${GRAY}down${NC}            Stop application stack"
  echo -e "    ${GRAY}logs${NC}            View Docker container logs"
  echo -e "    ${GRAY}clean${NC}           Clean Docker resources"
  echo -e "  ${CYAN}hooks${NC}             Git hooks"
  echo -e "    ${GRAY}install${NC}         Install Git hooks"
  echo -e "    ${GRAY}check${NC}           Run pre-commit checks manually\n"
  echo -e "${BOLD}Examples:${NC}"
  echo -e "  ./run setup               # Setup development environment"
  echo -e "  ./run db start            # Start the database"
  echo -e "  ./run dev run             # Run in development mode"
  echo -e "  ./run docker build latest # Build Docker image with 'latest' tag"
}

# Function to setup the development environment
setup_dev() {
  log_step "Setting up development environment"
  
  # Check for Java installation
  if ! command -v java &>/dev/null; then
    log_error "Java is not installed or not in PATH"
    log_info "Please install Java 17 or later and try again"
    exit 1
  fi
  
  # Check Java version
  java_version=$(java -version 2>&1 | awk -F '"' '/version/ {print $2}')
  if [[ ! "$java_version" =~ ^1[7-9] && ! "$java_version" =~ ^[2-9][0-9] ]]; then
    log_warn "Java version $java_version may not be compatible"
    log_info "HireSync requires Java 17 or later"
  fi
  
  # Check for Maven
  if ! command -v mvn &>/dev/null; then
    log_error "Maven is not installed or not in PATH"
    log_info "Please install Maven and try again"
    exit 1
  fi
  
  # Check for Docker
  if ! command -v docker &>/dev/null; then
    log_warn "Docker is not installed or not in PATH"
    log_info "Docker is recommended for development"
  fi
  
  # Create .env file if it doesn't exist
  if [[ ! -f "${PROJECT_ROOT}/.env" ]]; then
    log_info "Creating environment file"
    create_env_file
  fi
  
  # Install Git hooks
  install_git_hooks
  
  # Initialize database
  log_info "Setting up database"
  db_start
  db_init
  
  log_success "Development environment setup complete"
}

# Function to install Git hooks
install_git_hooks() {
  log_step "Installing Git hooks"
  
  # Check if .git directory exists
  if [[ ! -d "${PROJECT_ROOT}/.git" ]]; then
    log_warn "Not a Git repository, skipping hooks installation"
    return 1
  fi
  
  # Create hooks directory if it doesn't exist
  mkdir -p "${PROJECT_ROOT}/.git/hooks"
  
  # Install pre-commit hook
  log_info "Installing pre-commit hook"
  cat > "${PROJECT_ROOT}/.git/hooks/pre-commit" << 'EOF'
#!/bin/bash
exec "$(dirname "$(dirname "$0")")/run" hooks check
EOF
  chmod +x "${PROJECT_ROOT}/.git/hooks/pre-commit"
  
  log_success "Git hooks installed successfully"
}

# Function to run Git hook checks
run_hook_checks() {
  log_step "Running pre-commit checks"
  
  # Run Maven verify
  log_info "Running code quality checks"
  mvn clean verify -DskipTests
  
  log_success "All checks passed"
}

# Function to run development tasks
run_dev_command() {
  case "$SUB_COMMAND" in
    run)
      log_step "Running application in development mode"
      mvn spring-boot:run
      ;;
    test)
      log_step "Running tests"
      mvn test
      ;;
    clean)
      log_step "Cleaning build artifacts"
      mvn clean
      log_success "Cleaned build artifacts"
      ;;
    *)
      log_error "Unknown dev subcommand: $SUB_COMMAND"
      echo -e "Available subcommands: run, test, clean"
      exit 1
      ;;
  esac
}

# Parse command line arguments
parse_args() {
  COMMAND="$1"
  shift || true
  
  if [[ -n "$1" ]]; then
    SUB_COMMAND="$1"
    shift || true
  fi
  
  ARGS=("$@")
}

# Main function to route commands
main() {
  # Show help if no arguments
  if [[ $# -eq 0 ]]; then
    show_help
    exit 0
  fi
  
  parse_args "$@"
  
  # Process commands
  case "$COMMAND" in
    help)
      show_help
      ;;
    setup)
      setup_dev
      ;;
    db)
      case "$SUB_COMMAND" in
        start)
          db_start
          ;;
        stop)
          db_stop
          ;;
        status)
          db_status
          ;;
        init)
          db_init
          ;;
        backup)
          db_backup "${ARGS[0]:-backups}"
          ;;
        restore)
          if [[ -n "${ARGS[0]}" ]]; then
            db_restore "${ARGS[0]}"
          else
            log_error "Backup file path required"
            echo "Usage: ./run db restore <backup_file>"
            exit 1
          fi
          ;;
        shell)
          db_shell
          ;;
        *)
          log_error "Unknown db subcommand: $SUB_COMMAND"
          echo -e "Available subcommands: start, stop, status, init, backup, restore, shell"
          exit 1
          ;;
      esac
      ;;
    dev)
      run_dev_command
      ;;
    docker)
      case "$SUB_COMMAND" in
        build)
          docker_build "${ARGS[0]:-latest}"
          ;;
        up)
          docker_up
          ;;
        down)
          docker_down
          ;;
        logs)
          docker_logs "${ARGS[0]:-app}"
          ;;
        clean)
          docker_clean
          ;;
        *)
          log_error "Unknown docker subcommand: $SUB_COMMAND"
          echo -e "Available subcommands: build, up, down, logs, clean"
          exit 1
          ;;
      esac
      ;;
    hooks)
      case "$SUB_COMMAND" in
        install)
          install_git_hooks
          ;;
        check)
          run_hook_checks
          ;;
        *)
          log_error "Unknown hooks subcommand: $SUB_COMMAND"
          echo -e "Available subcommands: install, check"
          exit 1
          ;;
      esac
      ;;
    *)
      log_error "Unknown command: $COMMAND"
      show_help
      exit 1
      ;;
  esac
}

# Run the main function with all arguments
main "$@"