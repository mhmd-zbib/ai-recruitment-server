#!/bin/bash
# HireSync PostgreSQL Starter
# This script only starts the PostgreSQL container without the development tools container
# Useful when you want to run the application directly on your host machine

set -e

# Set script directory 
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
LOG_DIR="$PROJECT_ROOT/logs"
LOG_FILE="$LOG_DIR/hiresync-postgres-$(date +%Y%m%d-%H%M%S).log"
START_TIME=$(date +%s)

# Create logs directory if it doesn't exist
mkdir -p "$LOG_DIR"

# Define colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Logging functions
log() {
  local level=$1
  local message=$2
  local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
  local elapsed=$(( $(date +%s) - START_TIME ))
  echo -e "[$timestamp] [$level] [${elapsed}s] $message" | tee -a "$LOG_FILE"
}

log_info() {
  log "INFO" "${CYAN}$1${NC}"
}

log_warning() {
  log "WARNING" "${YELLOW}$1${NC}"
}

log_error() {
  log "ERROR" "${RED}$1${NC}"
}

log_success() {
  log "SUCCESS" "${GREEN}$1${NC}"
}

log_step() {
  log "STEP" "${BOLD}${BLUE}$1${NC}"
}

# Error handler
handle_error() {
  local exit_code=$?
  log_error "An error occurred (exit code: $exit_code)"
  log_error "Check the log file for details: $LOG_FILE"
  exit $exit_code
}

# Set up trap for error handling
trap handle_error ERR

# Load environment variables
load_env_variables() {
  log_step "LOADING ENVIRONMENT VARIABLES"
  
  local env_file="$PROJECT_ROOT/.env"
  if [ -f "$env_file" ]; then
    log_info "Found .env file at: $env_file"
    set -a
    source "$env_file"
    set +a
    log_success "Environment variables loaded successfully"
    
    # Set default values for any missing variables
    export DB_HOST=${DB_HOST:-localhost}
    export DB_PORT=${DB_PORT:-5432}
    export DB_NAME=${DB_NAME:-hiresync}
    export DB_USER=${DB_USER:-hiresync}
    export DB_PASSWORD=${DB_PASSWORD:-hiresync}
    
    log_debug "Database config: host=$DB_HOST, port=$DB_PORT, name=$DB_NAME, user=$DB_USER"
  else
    log_error ".env file not found at: $env_file"
    log_info "Checking for .env.example to create a default .env file..."
    
    if [ -f "$PROJECT_ROOT/.env.example" ]; then
      log_info "Creating default .env file from example..."
      cp "$PROJECT_ROOT/.env.example" "$env_file"
      
      # Load again
      set -a
      source "$env_file"
      set +a
      log_success "Created and loaded default .env file. Please review and update as needed."
    else
      log_error "No .env.example file found. Cannot continue."
      exit 1
    fi
  fi
}

# Check if Docker is running
check_docker() {
  log_step "CHECKING DOCKER STATUS"
  
  if ! command -v docker &> /dev/null; then
    log_error "Docker is not installed or not in PATH"
    exit 1
  fi
  
  log_info "Testing Docker connection..."
  if ! docker info &> /dev/null; then
    log_error "Docker daemon is not running. Please start Docker and try again."
    exit 1
  fi
  
  # Get Docker version
  local docker_version=$(docker --version)
  log_success "Docker is running: $docker_version"
  
  # Check Docker Compose
  if ! command -v docker-compose &> /dev/null; then
    log_error "Docker Compose is not installed or not in PATH"
    exit 1
  fi
  
  # Get Docker Compose version
  local compose_version=$(docker-compose --version)
  log_success "Docker Compose is available: $compose_version"
}

# Manage Docker network
setup_docker_network() {
  log_step "SETTING UP DOCKER NETWORK"
  
  local network_name="hiresync-network"
  
  # Check if network exists
  if docker network inspect "$network_name" &> /dev/null; then
    log_success "Docker network '$network_name' already exists"
  else
    log_info "Creating Docker network '$network_name'..."
    docker network create --driver bridge "$network_name"
    log_success "Docker network created successfully"
  fi
}

# Function to check and manage Docker volumes
setup_docker_volumes() {
  log_step "SETTING UP DOCKER VOLUMES"
  
  # Create postgres data volume if it doesn't exist
  local pg_volume="hiresync-postgres-data"
  if docker volume inspect "$pg_volume" &> /dev/null; then
    log_success "Docker volume '$pg_volume' already exists"
  else
    log_info "Creating Docker volume '$pg_volume'..."
    docker volume create "$pg_volume"
    log_success "Docker volume '$pg_volume' created successfully"
  fi
}

# Pull Docker images
pull_docker_images() {
  log_step "PULLING REQUIRED DOCKER IMAGES"
  
  log_info "Pulling PostgreSQL image..."
  docker pull postgres:16-alpine
  log_success "PostgreSQL image pulled successfully"
}

# Start PostgreSQL container
start_postgres_container() {
  log_step "STARTING POSTGRESQL CONTAINER"
  
  local compose_file="$PROJECT_ROOT/docker/docker-compose.local.yaml"
  log_info "Using docker-compose file: $compose_file"
  
  # Log restart policies
  log_info "Container restart policies:"
  log_info "  - PostgreSQL: ${DB_RESTART_POLICY:-unless-stopped}"
  
  # Validate docker-compose file
  log_info "Validating docker-compose file..."
  if ! docker-compose -f "$compose_file" config > /dev/null; then
    log_error "Invalid docker-compose file. Please check the syntax."
    exit 1
  fi
  
  # Force stop any existing containers with the same names to avoid conflicts
  log_info "Checking for existing containers..."
  
  for container in "hiresync-postgres"; do
    if docker ps -a -q --filter "name=$container" | grep -q .; then
      log_info "Found existing container: $container. Removing it..."
      
      # Stop container if it's running
      if docker ps -q --filter "name=$container" | grep -q .; then
        log_info "Stopping container: $container"
        docker stop "$container" > /dev/null
      fi
      
      # Remove container
      log_info "Removing container: $container"
      docker rm "$container" > /dev/null
    fi
  done
  
  # Start PostgreSQL container
  log_info "Starting PostgreSQL container..."
  if docker-compose -f "$compose_file" up -d postgres; then
    log_success "PostgreSQL container started successfully"
  else
    log_error "Failed to start PostgreSQL container. Check docker logs for details."
    docker-compose -f "$compose_file" logs postgres
    exit 1
  fi
}

# Wait for PostgreSQL to be ready
wait_for_postgres() {
  log_step "WAITING FOR POSTGRESQL TO BE READY"
  
  local max_attempts=30
  local attempt=0
  local container_name="hiresync-postgres"
  
  log_info "Waiting for PostgreSQL container to start..."
  while [ $attempt -lt $max_attempts ]; do
    if ! docker ps --format '{{.Names}}' | grep -q "$container_name"; then
      log_error "PostgreSQL container is not running"
      docker logs "$container_name"
      exit 1
    fi
    
    log_info "Testing PostgreSQL connection (attempt $((attempt+1))/$max_attempts)..."
    if docker exec "$container_name" pg_isready -U "$DB_USER" -d "$DB_NAME" > /dev/null 2>&1; then
      log_success "PostgreSQL is ready and accepting connections"
      
      # Display connection details
      log_info "PostgreSQL Connection Details:"
      log_info "  Host:     localhost (from host machine)"
      log_info "  Port:     ${DB_PORT}"
      log_info "  Database: ${DB_NAME}"
      log_info "  Username: ${DB_USER}"
      log_info "  Password: ${DB_PASSWORD}"
      return 0
    fi
    
    attempt=$((attempt + 1))
    sleep 2
  done
  
  log_error "PostgreSQL did not become ready within the timeout period ($((max_attempts*2)) seconds)"
  log_error "PostgreSQL container logs:"
  docker logs "$container_name"
  exit 1
}

# Apply database migrations if needed
apply_db_migrations() {
  log_step "CHECKING DATABASE MIGRATIONS"
  
  local db_dir="${DB_SCRIPTS_DIR:-$PROJECT_ROOT/db}"
  
  if [ -d "$db_dir" ]; then
    local sql_count=$(find "$db_dir" -name "*.sql" | wc -l)
    
    if [ "$sql_count" -gt 0 ]; then
      log_info "Found $sql_count SQL scripts in $db_dir"
      log_info "These will be automatically applied by the PostgreSQL container on first startup"
      log_success "Database migrations are set up correctly"
    else
      log_warning "No SQL scripts found in $db_dir"
      log_info "This is normal if your application uses JPA schema generation"
    fi
  else
    log_warning "Database scripts directory not found at $db_dir"
    log_info "This is normal if your application uses JPA schema generation"
  fi
}

# Setup logging
setup_logging() {
  log_info "============================================================"
  log_info "${BOLD}STARTING HIRESYNC POSTGRESQL CONTAINER${NC}"
  log_info "============================================================"
  log_info "Date/Time: $(date)"
  log_info "User: $(whoami)"
  log_info "System: $(uname -a)"
  log_info "Project Root: $PROJECT_ROOT"
}

# Check prerequisites
check_prerequisites() {
  # Load environment variables
  load_env_variables
  
  # Check Docker
  check_docker
}

# Main function
main() {
  setup_logging
  check_prerequisites
  pull_docker_images
  setup_docker_network  # Make sure network exists
  setup_docker_volumes  # Make sure volumes exist
  start_postgres_container
  
  # Wait for PostgreSQL to be ready
  wait_for_postgres
  
  # Apply database migrations if needed
  apply_db_migrations
  
  log_success "PostgreSQL is now ready!"
  log_info "Run your application with: ./hiresync run"
}

# Run the main function
main

# Calculate total execution time - this will only execute if the script completes successfully
END_TIME=$(date +%s)
TOTAL_TIME=$((END_TIME - START_TIME))
log_success "Script execution completed successfully in ${TOTAL_TIME} seconds" 