#!/bin/bash

# Efficient commit-msg hook to validate commit messages
# Enforces conventional commit format without external dependencies

# ANSI color codes for better output
GREEN="\033[0;32m"
YELLOW="\033[0;33m"
RED="\033[0;31m"
BLUE="\033[0;34m"
BOLD="\033[1m"
NC="\033[0m"

# Get the commit message file
COMMIT_MSG_FILE=$1
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

# Skip checks for merge and automated commits
if [[ "$COMMIT_MSG" =~ ^Merge\ branch.*$ ]] || \
   [[ "$COMMIT_MSG" =~ ^Merge\ pull\ request.*$ ]] || \
   [[ "$COMMIT_MSG" =~ ^Merge\ remote.*$ ]] || \
   [[ "$COMMIT_MSG" =~ ^Revert\ .*$ ]] || \
   [[ "$COMMIT_MSG" =~ ^Auto-commit:\ .*$ ]] || \
   [[ "$COMMIT_MSG" =~ ^Automatic:\ .*$ ]] || \
   [[ "$COMMIT_MSG" =~ ^CI:\ .*$ ]]; then
  echo -e "${GREEN}Automated commit detected. Skipping validation.${NC}"
  exit 0
fi

# Check for bypass flag
if [ -n "$BYPASS_COMMIT_MSG_HOOK" ]; then
  echo -e "${YELLOW}Bypassing commit message validation due to BYPASS_COMMIT_MSG_HOOK.${NC}"
  exit 0
fi

# Performance optimization: Only check the first line for format compliance
FIRST_LINE=$(head -n 1 "$COMMIT_MSG_FILE")

# Regular expression for conventional commits
# format: <type>[(scope)][!]: <description>
VALID_TYPES="feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert"
REGEX="^($VALID_TYPES)(\([a-z0-9 ,\-\_]+\))?(\!)?: .+$"

if ! [[ "$FIRST_LINE" =~ $REGEX ]]; then
  echo -e "${RED}${BOLD}ERROR: Commit message format is invalid${NC}"
  echo -e "${YELLOW}Please use the conventional commit format:${NC}"
  echo -e "  ${BLUE}<type>[(scope)][!]: <description>${NC}"
  echo
  echo -e "Valid types: ${BLUE}${VALID_TYPES//|/, }${NC}"
  echo -e "Examples:"
  echo -e "  ${GREEN}feat: add user authentication${NC}"
  echo -e "  ${GREEN}fix(api): resolve null pointer in user query${NC}"
  echo -e "  ${GREEN}docs: update README with setup instructions${NC}"
  echo -e "  ${GREEN}refactor!: change user API response format${NC}"
  echo
  echo -e "${YELLOW}Your commit:${NC} ${RED}$FIRST_LINE${NC}"
  exit 1
fi

# Quick check of commit message length
if [ ${#FIRST_LINE} -gt 100 ]; then
  echo -e "${YELLOW}WARNING: Commit headline is too long (${#FIRST_LINE} chars)${NC}"
  echo -e "  Try to keep the first line under 72 characters"
  # Continue anyway - this is just a warning
fi

# Check for body line length only if message has a body
if [ $(wc -l < "$COMMIT_MSG_FILE") -gt 1 ]; then
  # Optimization: Use grep to only check problematic lines, not all lines
  TOO_LONG_LINES=$(grep -n "^..\{101,\}$" "$COMMIT_MSG_FILE" | head -n 3)
  
  if [ -n "$TOO_LONG_LINES" ]; then
    echo -e "${YELLOW}WARNING: Some body lines are too long:${NC}"
    echo "$TOO_LONG_LINES" | while read -r line; do
      LINE_NUM=$(echo "$line" | cut -d: -f1)
      echo -e "  Line $LINE_NUM exceeds 100 characters"
    done
    # Just a warning, don't block commit
  fi
fi

# Check for explanatory text when using breaking changes
if [[ "$FIRST_LINE" =~ ^.+\!: ]]; then
  # Breaking change should have body that explains the change
  if [ $(grep -c "^BREAKING CHANGE:" "$COMMIT_MSG_FILE") -eq 0 ]; then
    echo -e "${YELLOW}WARNING: Breaking change marker (!) used without BREAKING CHANGE: explanation${NC}"
    echo -e "  Consider adding a 'BREAKING CHANGE: <explanation>' line to the commit message"
    # Just a warning, don't block commit
  fi
fi

echo -e "${GREEN}Commit message format is valid.${NC}"
exit 0 