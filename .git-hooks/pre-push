#!/bin/bash

# Optimized pre-push hook for modern development workflows
# Performs heavier checks before pushing to remote
# Designed for senior-level engineering teams

# Colors for better UX
GREEN="\033[0;32m"
YELLOW="\033[0;33m"
RED="\033[0;31m"
BLUE="\033[0;34m"
CYAN="\033[0;36m"
NC="\033[0m"

echo -e "${BLUE}Running pre-push quality checks...${NC}"

# Get repository root
REPO_ROOT=$(git rev-parse --show-toplevel)
CACHE_DIR="$REPO_ROOT/.git/hooks-cache"
mkdir -p "$CACHE_DIR" 2>/dev/null

# Parse arguments from Git
read local_ref local_sha remote_ref remote_sha

# Check for bypass flag
if [ -n "$GIT_BYPASS_HOOKS" ] || [ -n "$SKIP_PUSH_HOOKS" ]; then
  echo -e "${YELLOW}Bypassing pre-push hooks due to environment flag.${NC}"
  exit 0
fi

# Get target branch name
TARGET_BRANCH=${remote_ref#refs/heads/}
CURRENT_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null)

# Only run intensive checks for important branches
if [[ "$TARGET_BRANCH" == "master" || "$TARGET_BRANCH" == "dev" || "$TARGET_BRANCH" == "develop" || 
      "$TARGET_BRANCH" == "main" || "$TARGET_BRANCH" =~ ^release/.*$ ]]; then
  IMPORTANT_BRANCH=true
else
  IMPORTANT_BRANCH=false
fi

# Skip for branch deletions
if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
  echo -e "${BLUE}Branch deletion detected, skipping checks.${NC}"
  exit 0
fi

# Identify changes since remote
if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
  # New branch, check all commits
  echo -e "${BLUE}New branch, checking all commits...${NC}"
  FILES_CHANGED=$(git diff --name-only --diff-filter=ACMR $(git merge-base $local_sha main 2>/dev/null || git merge-base $local_sha master 2>/dev/null || echo HEAD~20) $local_sha)
else
  # Existing branch, check only new commits
  echo -e "${BLUE}Checking commits being pushed...${NC}"
  FILES_CHANGED=$(git diff --name-only --diff-filter=ACMR $remote_sha..$local_sha)
fi

# Filter for relevant files
JAVA_FILES=$(echo "$FILES_CHANGED" | grep -E '\.java$' || echo "")
CONFIG_FILES=$(echo "$FILES_CHANGED" | grep -E '\.xml$|\.properties$|\.yml$|\.yaml$' || echo "")
SQL_FILES=$(echo "$FILES_CHANGED" | grep -E '\.sql$' || echo "")
ALL_CODE_FILES=$(echo "$FILES_CHANGED" | grep -E '\.java$|\.xml$|\.properties$|\.yml$|\.yaml$|\.json$|\.md$|\.sql$' || echo "")

if [[ -z "$ALL_CODE_FILES" ]]; then
  echo -e "${GREEN}No code files modified, skipping code quality checks.${NC}"
  exit 0
fi

# Save a hash of files checked to avoid redundant checks
PUSH_HASH=$(echo "$ALL_CODE_FILES" | sort | md5sum | cut -d' ' -f1)
LAST_PUSH_HASH_FILE="$CACHE_DIR/last_push_hash"

if [ -f "$LAST_PUSH_HASH_FILE" ] && [ "$(cat "$LAST_PUSH_HASH_FILE")" = "$PUSH_HASH" ] && [ "${FORCE_CHECKS}" != "true" ]; then
  # Identical set of files was already checked
  if [[ "$IMPORTANT_BRANCH" != "true" ]]; then
    echo -e "${CYAN}These files were recently verified, skipping checks.${NC}"
    echo -e "${CYAN}(Set FORCE_CHECKS=true to force checking)${NC}"
    exit 0
  fi
  echo -e "${CYAN}Pushing to important branch, running checks even though files were recently verified.${NC}"
fi

# Helper function for Maven execution
run_maven() {
  local CMD=$1
  local MSG=$2
  local REQUIRED=${3:-false}
  
  echo -e "   ${CYAN}→ ${MSG}...${NC}"

  MAVEN_OUT=$(mktemp)
  if [ -f "$REPO_ROOT/mvnw" ]; then
    $REPO_ROOT/mvnw -q $CMD > $MAVEN_OUT 2>&1
  else 
    mvn -q $CMD > $MAVEN_OUT 2>&1
  fi
  
  EXIT_CODE=$?
  if [ $EXIT_CODE -ne 0 ]; then
    if [[ "$REQUIRED" == "true" ]]; then
      echo -e "${RED}Required check failed: ${MSG}${NC}"
      echo -e "${YELLOW}Error output:${NC}"
      tail -n 20 $MAVEN_OUT
      rm $MAVEN_OUT
      return 1
    else
      echo -e "${YELLOW}Warning: ${MSG} had issues, but continuing anyway.${NC}"
      echo -e "${YELLOW}See log for details: $MAVEN_OUT${NC}"
      return 0
    fi
  fi
  
  rm $MAVEN_OUT
  return 0
}

# Run in parallel for improved performance
run_parallel_tasks() {
  local PIDS=()

  # Run fast checks first
  echo -e "${BLUE}Running code quality checks...${NC}"
  
  # Spotless (formatting) - important, but relatively fast
  run_maven "spotless:check" "Checking code formatting" false &
  PIDS+=($!)

  # Normalize line endings for all staged files
  echo -e "${CYAN}→ Normalizing line endings...${NC}"
  if [ -f "$REPO_ROOT/.git-hooks/correct-line-endings.sh" ]; then
    bash "$REPO_ROOT/.git-hooks/correct-line-endings.sh" > /dev/null 2>&1 &
    PIDS+=($!)
  fi
  
  # Wait for first batch to complete
  for PID in "${PIDS[@]}"; do
    wait $PID
  done
  
  # Clear PIDs array for next batch
  PIDS=()
  
  # Run more intensive checks only for important branches or if specifically requested
  if [[ "$IMPORTANT_BRANCH" == "true" || "${FULL_CHECKS}" == "true" ]]; then
    echo -e "${BLUE}Running comprehensive checks for main branch...${NC}"
    
    # Checkstyle
    run_maven "checkstyle:check" "Checking code style" true &
    PIDS+=($!)
    
    # Wait for second batch
    for PID in "${PIDS[@]}"; do
      wait $PID
      if [ $? -ne 0 ]; then
        echo -e "${RED}Push aborted due to failed checks.${NC}"
        echo -e "${YELLOW}Fix the issues or use SKIP_PUSH_HOOKS=true to bypass.${NC}"
        exit 1
      fi
    done
    
    # Clear PIDs array for final batch
    PIDS=()
    
    # Critical SpotBugs (security only, fast)
    run_maven "com.github.spotbugs:spotbugs-maven-plugin:check -Dspotbugs.threshold=High -Dspotbugs.effort=Min" "Checking for critical bugs" true &
    PIDS+=($!)
    
    # Run tests if Java files were modified (and this is an important branch)
    if [[ -n "$JAVA_FILES" ]]; then
      echo -e "${CYAN}→ Running tests for modified code...${NC}"
      
      # For large projects, only run tests related to modified files to save time
      CLASSES_CHANGED=$(echo "$JAVA_FILES" | sed 's/\.java$/,/g' | tr -d '\n')
      if [ -n "$CLASSES_CHANGED" ]; then
        run_maven "test -Dtest=${CLASSES_CHANGED%,} -Dspring.profiles.active=test" "Running targeted tests" true &
        PIDS+=($!)
      fi
    fi
    
    # Wait for final batch
    for PID in "${PIDS[@]}"; do
      wait $PID
      if [ $? -ne 0 ]; then
        echo -e "${RED}Push aborted due to failed checks.${NC}"
        echo -e "${YELLOW}Fix the issues or use SKIP_PUSH_HOOKS=true to bypass.${NC}"
        exit 1
      fi
    done
  else
    # For non-important branches, run minimal checks
    echo -e "${CYAN}Running minimal checks for feature branch...${NC}"
    
    # Compile only
    run_maven "compile" "Compiling code" true
    if [ $? -ne 0 ]; then
      echo -e "${RED}Push aborted due to compilation errors.${NC}"
      exit 1
    fi
  fi
  
  # Save hash to avoid redundant checks
  echo "$PUSH_HASH" > "$LAST_PUSH_HASH_FILE"
}

# Special case for important branches - don't allow skipping (requires override)
if [[ "$IMPORTANT_BRANCH" == "true" && -n "$SKIP_PUSH_HOOKS" && -z "$FORCE_PUSH" ]]; then
  echo -e "${RED}Warning: You're trying to bypass hooks for an important branch.${NC}"
  echo -e "${YELLOW}To force this push, use FORCE_PUSH=true SKIP_PUSH_HOOKS=true${NC}"
  exit 1
fi

# Reminder for large pushes
COMMIT_COUNT=$(git rev-list --count $remote_sha..$local_sha 2>/dev/null || echo "many")
if [ "$COMMIT_COUNT" -gt 10 ] 2>/dev/null; then
  echo -e "${YELLOW}You're pushing $COMMIT_COUNT commits. Consider smaller, focused pushes.${NC}"
fi

# Run the parallel tasks
run_parallel_tasks

# Success message at completion
echo -e "${GREEN}✅ Pre-push checks passed! Pushing to $TARGET_BRANCH...${NC}"
exit 0 